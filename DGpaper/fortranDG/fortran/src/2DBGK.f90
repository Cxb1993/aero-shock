PROGRAM SCI_BGK_2D
IMPLICIT REAL(8) (A-H,O-Z)
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
REAL, DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F,FEQ
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY)         :: UX,UY,Z,T,R,ET,P 
REAL, DIMENSION (IMAXGRIDX)					  :: X,Y  !/IMAXGRIDY ASSUMING SYMM. DOMAIN
REAL, DIMENSION (IGH)						  :: C,V
!	A DIRECT SOLVER AUTHORED BY BAGUS P. MULJADI (D97543016@NTU.EDU.TW)
!	FOR SOLVING 2D-RIEMANN PROBLEMS OF SEMICLASSICAL BOLTZMANN-BGK EQUATION
!	USING TVD AND DISCRETE ORDINATE METHOD
MX			= 20
MY			= 20
NX          = MX+3	
NY          = MY+3	
CFL         = 0.8
OUTTIME     = 0.2
THETA       = 0.	! MAXWELLIAN = 0., FERMION = 1., BOSON = -1.
ISOLVER		= 0		! EULER = 0, BGK = 1
R_TIME		= 0.01	! RELAXATION TIME 
NV			= 20 	! DISCRETIZED VELOCITY POINTS (UNIFORM FOR VX AND VY)
OPEN (UNIT = 10, FILE = 'ABSCISSAS.TEC', STATUS = 'UNKNOWN')
OPEN (UNIT = 20, FILE = 'SV_POINT(1).TEC', STATUS = 'UNKNOWN')
OPEN (UNIT = 30, FILE = 'SV_POINT(2).TEC', STATUS = 'UNKNOWN')
OPEN (UNIT = 60, FILE = 'RESULTS.TEC', STATUS = 'UNKNOWN')
    WRITE(20,888)
    WRITE(30,888)
	WRITE(60,888)
	WRITE(20,*) 'ZONE T="SV_POINT(1)",I=',NX-2,',J=',NY-2
    WRITE(30,*) 'ZONE T="SV_POINT(2)",I=',NX-2,',J=',NY-2
    WRITE(60,*) 'ZONE T="RESULTS",I=',NX-2,',J=',NY-2
888 FORMAT ('VARIABLES = "X","Y","N","P","Z"')    
CALL WEIGHTINGS_GAUSS_HERMITE (NV,C,V)
CALL QUADRANTS_VALS(Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4)
CALL GRID2 (NX,NY,DX,DY,X,Y)
CALL INITIALIZATION (NV,NX,NY,X,Y,THETA,Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4,V,Z,UX,UY,T,F)
ITER  = 1
TIME  = 0
ISTOP = 0
1000 CONTINUE
CALL CALDT (NV,DX,DY,CFL,ISTOP,TIME,OUTTIME,V,DT,DTDX,DTDY)
CALL EQUILIBRIUM (NV,NX,NY,THETA,V,Z,UX,UY,T,FEQ)
	IF (ISOLVER.EQ.0) THEN
	CALL EU_PROJECTION (NX,NY,NV,F,FEQ)
	END IF
CALL ITERATION (NV,NX,NY,DTDX,DTDY,DT,R_TIME,FEQ,V,F)
CALL CALDOM (NX,NY,NV,C,V,F,R,UX,UY,ET)
	IF (THETA .EQ. 0.) GO TO 1100
CALL BISECT_ZTP (NX,NY,THETA,R,UX,UY,ET,Z,T,P)
GO TO 1300
1100 CONTINUE
CALL MAXWELLIAN_ZTP (NX,NY,R,UX,UY,ET,Z,T,P)
   
1300 CONTINUE
CALL WRT_SAVINGPOINTS (NX,NY,ITER,OUTTIME,DT,X,Y,R,P,Z)
WRITE(*,777) TIME, R(NX/2,NY/2)
777	FORMAT (1X,'ELAPSED TIME:',F7.4,4X, 'DENSITY AT X=0.5,Y=0.5:',F7.4)
IF (ISTOP .EQ. 1) GOTO 2000
ITER = ITER + 1
GOTO 1000
2000 CONTINUE

CALL WRT_RESULTS (NX,NY,X,Y,R,P,Z)
STOP
END PROGRAM    
!==================!				   
!	SUBROUTINES	   !
!==================!
SUBROUTINE QUADRANTS_VALS(Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4)
IMPLICIT NONE
REAL(8) Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4
	Z1   = 0.142
    UX1  = -0.75
    UY1  = -0.5
    T1   = 2.078
    Z2   = 0.4253
    UX2  = -0.75
    UY2  = 0.5
    T2   = 1.1494
    Z3   = 0.142
    UX3  = 0.75
    UY3  = 0.5
    T3   = 2.078
    Z4   = 0.6635
    UX4  = 0.75
    UY4  = -0.5
    T4   = 0.87685
RETURN
END SUBROUTINE
!
SUBROUTINE GRID2 (NX,NY,DX,DY,X,Y)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,NX,NY
REAL(8) DX,DY
REAL, DIMENSION (IMAXGRIDX) :: X,Y
DX = 1./DFLOAT(NX-3)
DY = 1./DFLOAT(NY-3)

X(1)=0.-DX
Y(1)=0.-DY
DO I = 2,NX
	X(I) = X(I-1) + DX
END DO
DO J = 2,NY
	Y(J) = Y(J-1) + DY
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE WEIGHTINGS_GAUSS_HERMITE (NV,C,V)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,NV
REAL,DIMENSION (IGH):: C,V,GH,W
GH(:) =(/-5.38748089001,-4.60368244955,-3.94476404012,-3.34785456738,-2.78880605843,-2.25497400209,-1.73853771212,-1.2340762154,-0.737473728545,-0.245340708301,0.245340708301,0.737473728545,1.2340762154,1.73853771212,2.25497400209,2.78880605843,3.34785456738,3.94476404012,4.60368244955,5.38748089001/)
W(:)  =(/0.898591961453,0.704332961176,0.62227869619,0.575262442852,0.544851742366,0.524080350949,0.509679027117,0.499920871336,0.493843385272,0.490921500667,0.490921500667,0.493843385272,0.499920871336,0.509679027117,0.524080350949,0.544851742366,0.575262442852,0.62227869619,0.704332961176,0.898591961453/)
!
DO I = 1, NV
    C(I)    = W(I)
    V(I)    = GH(I)
    WRITE (10,*) C(I),V(I)    
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE INITIALIZATION (NV,NX,NY,X,Y,THETA,Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4,V,Z,UX,UY,T,F)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NX,NY,NV
REAL(8) Z1,UX1,UY1,T1,Z2,UX2,UY2,T2,Z3,UX3,UY3,T3,Z4,UX4,UY4,T4,PP,THETA
REAL, DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY) :: Z,UX,UY,T
REAL, DIMENSION (IMAXGRIDX) :: X,Y
REAL, DIMENSION (IGH) :: V 
DO I = 1,NX
  DO J = 1,NY
	IF ((Y(J) .LE. 0.5) .AND. (X(I) .GE. 0.5))  THEN
	  Z(I,J) = Z4
	  UX(I,J) = UX4
	  UY(I,J) = UY4
	  T(I,J) = T4
	 ELSE IF ((Y(J) .GE. 0.5) .AND. (X(I) .LE. 0.5))	THEN
	  Z(I,J) = Z2
	  UX(I,J) = UX2
	  UY(I,J) = UY2
	  T(I,J) = T2
	 ELSE IF ((Y(J) .GE. 0.5) .AND. (X(I) .GE. 0.5)) THEN
	  Z(I,J) = Z1
	  UX(I,J) = UX1
	  UY(I,J) = UY1
	  T(I,J) = T1
	 ELSE
	  Z(I,J) = Z3
	  UX(I,J) = UX3
	  UY(I,J) = UY3
	  T(I,J) = T3
	END IF
	DO K = 1,NV
	  DO L = 1,NV
		PP = ( (V(K)-UX(I,J))**2 + (V(L)-UY(I,J))**2 ) / T(I,J)
		F(K,L,I,J) = 1/((EXP(PP)/Z(I,J))+THETA)
	  END DO
	END DO
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE EQUILIBRIUM (NV,NX,NY,THETA,V,Z,UX,UY,T,F0)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
REAL,DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F0
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: Z,UX,UY,T
REAL,DIMENSION (IGH) :: V
INTEGER NV,NX,NY,K,L,I,J
REAL(8) PP,THETA
DO I = 1, NX
  DO J = 1, NY
	DO K = 1,NV
	  DO L = 1,NV
		PP = ( (V(K)-UX(I,J))**2 + (V(L)-UY(I,J))**2 ) / T(I,J)
		F0(K,L,I,J) = 1/((EXP(PP)/Z(I,J))+THETA)
	  END DO
	END DO
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE EU_PROJECTION (NX,NY,NV,F,F0)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NX,NY,NV
REAL,DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F,F0
DO I = 1, NX
  DO J = 1, NY
    DO K = 1, NV
      DO L = 1, NV
        F(K,L,I,J) = F0(K,L,I,J)	
      END DO
    END DO  
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE CALDT (NV,DX,DY,CFL,ISTOP,TIME,OUTTIME,V,DT,DTDX,DTDY)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER NV,ISTOP
REAL(8) DX,DY,CFL,TIME,OUTTIME,DT,DTDX,DTDY,DTCFL
REAL,DIMENSION (IGH) :: V
DT = MIN(DX,DY) * CFL/V(NV)
TIME = TIME + DT
DTDX = DT/DX
DTDY = DT/DY
!    
IF (TIME .GT. OUTTIME) THEN
    DTCFL = OUTTIME - (TIME - DTCFL)  
    TIME = OUTTIME
    DT = DTCFL/CFL
    DTDX = DTCFL / DX
    DTDY = DTCFL / DY
    ISTOP = 1
END IF
RETURN
END SUBROUTINE
!
SUBROUTINE CALDOM (NX,NY,NV,C,V,F,R,UX,UY,ET)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NX,NY,NV
REAL(8) SR,SUX,SUY,SE
REAL, DIMENSION (IGH) :: C,V
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY) :: R,UX,UY,ET
REAL, DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F
DO I = 1, NX
  DO J = 1, NY
    SR  = 0
    SUX = 0
    SUY = 0
    SE  = 0
      DO K = 1, NV
        DO L = 1, NV
         SR  = SR + C(K)*C(L) * F(K,L,I,J)
         SUX = SUX + C(K)*C(L) * F(K,L,I,J) * V(K)
         SUY = SUY + C(K)*C(L) * F(K,L,I,J) * V(L)
         SE  = SE + C(K)*C(L) * F(K,L,I,J) * (0.5 * (V(K)*V(K) + V(L)*V(L)))
        END DO
      END DO
    R(I,J)    = SR
    UX(I,J)   = SUX/SR 
    UY(I,J)   = SUY/SR
    ET(I,J)   = SE       
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE BISECT_ZTP (NX,NY,THETA,R,UX,UY,ET,Z,T,P)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER L,I,J,NX,NY
REAL(8) PI,ZA,ZB,ZC,GA1,GB1,GC1,GA2,GB2,GC2,PSIA,PSIB,PSIC,THETA
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY)::R,UX,UY,ET,Z,T,P
PI = ATAN2(1.,1.)*4.
DO I = 1, NX
 DO J = 1, NY
  ZA = 0.001
  ZB = 0.9
  DO WHILE (ABS(ZA-ZB) .GT. 1D-10)
    GA1 = 0
    GB1 = 0
    GA2 = 0
    GB2 = 0
        DO L = 1, 100
            IF (THETA .EQ. 1.) THEN      
            GA1 = GA1 + (ZA**L) * (-1)**(L-1)/L
            GB1 = GB1 + (ZB**L) * (-1)**(L-1)/L
            GA2 = GA2 + (ZA**L) * (-1)**(L-1)/(L**2)
            GB2 = GB2 + (ZB**L) * (-1)**(L-1)/(L**2)
            ELSE
            GA1 = GA1 + (ZA**L) /L
            GB1 = GB1 + (ZB**L) /L
            GA2 = GA2 + (ZA**L) /(L**2)
            GB2 = GB2 + (ZB**L) /(L**2)
            END IF    
        END DO
    PSIA = 2*ET(I,J) - (GA2*(R(I,J)/GA1)**2)/PI - R(I,J)*(UX(I,J)*UX(I,J)+UY(I,J)*UY(I,J))
    PSIB = 2*ET(I,J) - (GB2*(R(I,J)/GB1)**2)/PI - R(I,J)*(UX(I,J)*UX(I,J)+UY(I,J)*UY(I,J))
    ZC = (ZA+ZB)/2
    GC1 = 0
    GC2 = 0
        DO L = 1, 100
            IF (THETA .EQ. 1.) THEN
            GC1 = GC1 + (ZC**L) * (-1)**(L-1)/L
            GC2 = GC2 + (ZC**L) * (-1)**(L-1)/(L**2)
            ELSE 
            GC1 = GC1 + (ZC**L)/L
            GC2 = GC2 + (ZC**L)/(L**2)
            END IF
        END DO
    PSIC = 2*ET(I,J) - (GC2*(R(I,J)/GC1)**2)/PI - R(I,J)*(UX(I,J)*UX(I,J)+UY(I,J)*UY(I,J))
    IF ((PSIA*PSIC) .LT. 0) THEN
        ZB = ZC
    ELSE
        ZA = ZC
    END IF
  END DO
  Z(I,J) = ZC
  T(I,J) = R(I,J)/(PI*GC1)
  P(I,J) = ET(I,J) - 0.5*R(I,J)*(UX(I,J)**2+UY(I,J)**2)
 END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE MAXWELLIAN_ZTP (NX,NY,R,UX,UY,ET,Z,T,P)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER	NX,NY,I,J
REAL(8) PI
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: R,UX,UY,ET,Z,T,P
PI = ATAN2(1.,1.)*4
DO I = 1, NX
 DO J = 1, NY
  T(I,J) = (2* ET(I,J)/R(I,J))-(UX(I,J)**2+UY(I,J)**2)
  Z(I,J) = R(I,J)/(PI*T(I,J))
  P(I,J) = R(I,J)*T(I,J)/2
 END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE WRT_SAVINGPOINTS (NX,NY,ITER,OUTTIME,DT,X,Y,R,P,Z)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER ITER,I,J,NX,NY
REAL(8)	DT,SV_POINT1,SV_POINT2,OUTTIME
REAL,DIMENSION (IMAXGRIDX) :: X,Y
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: R,P,Z
SV_POINT1 = (1./3.)*OUTTIME   
SV_POINT2 = (2./3.)*OUTTIME
DO I = 2, NX-1
  DO J = 2, NY-1
   IF (ITER.EQ.FLOOR(SV_POINT1/DT)) THEN
     WRITE (20,*) X(I), Y(J), R(I,J), P(I,J), Z(I,J)
   ELSE IF (ITER.EQ.FLOOR(SV_POINT2/DT)) THEN
     WRITE (30,*) X(I), Y(J), R(I,J), P(I,J), Z(I,J)
   END IF
  END DO 
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE ITERATION (NV,NX,NY,DTDX,DTDY,DT,R_TIME,FEQ,V,F)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NV,NX,NY
REAL(8)	VXP,VXM,VYP,VYM,DTDX,DTDY,DT,R_TIME
REAL,DIMENSION (IGH) :: V
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) ::FN,FL,FH,GL,GH2
REAL,DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F,FEQ
DO K = 1, NV
  DO L = 1, NV
    VXP = MAX(V(K),0.)
    VXM = MIN(V(K),0.) 
    VYP = MAX(V(L),0.)
    VYM = MIN(V(L),0.)
    CALL TVDFLUXES (NX,NY,K,L,VXP,VXM,VYP,VYM,DTDX,DTDY,V,F,FL,FH,GL,GH2)
!	CALL EXPLICIT (K,L,NX,NY,FL,FH,GL,GH2,DT,DTDX,DTDY,FEQ,F,R_TIME,FN)
	CALL IMPLICIT_MTD (NX,NY,K,L,VXP,VYP,VXM,VYM,FL,FH,GL,GH2,DT,DTDX,DTDY,F,FN)
	DO I = 2,NX-1
	  DO J = 2,NY-1
		F(K,L,I,J) = FN(I,J)
	    CALL B_COND (K,L,I,J,NX,NY,FN,F)
	  END DO
	END DO	  
  END DO
END DO
RETURN
END SUBROUTINE 
!
SUBROUTINE TVDFLUXES (NX,NY,K,L,VXP,VXM,VYP,VYM,DTDX,DTDY,V,F,FL,FH,GL,GH2)
IMPLICIT NONE		 
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
REAL,DIMENSION (IGH) :: V
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: THA,THB,PHIA,PHIB
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) ::FLL,FLH,FL,FHL,FHH,FH,GLL,GLH,GL,GHL,GHH,GH2
REAL,DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F
INTEGER K,L,I,J,NX,NY
REAL(8) VXP,VXM,VYP,VYM,DTDX,DTDY 
! THETA
    DO I = 2, NX-1
      DO J = 2, NY-1
        IF (F(K,L,I+1,J) .EQ. F(K,L,I,J)) THEN
            THA(I,J) =  0
        ELSE
            THA(I,J) = (F(K,L,I-SIGN(1.,V(K))+1,J) - F(K,L,I-SIGN(1.,V(K)),J))/(F(K,L,I+1,J)-F(K,L,I,J))
        END IF 
        IF (F(K,L,I,J+1) .EQ. F(K,L,I,J)) THEN
            THB(I,J) =  0
        ELSE
            THB(I,J) = (F(K,L,I,J-SIGN(1.,V(L))+1) - F(K,L,I,J-SIGN(1.,V(L))))/(F(K,L,I,J+1)-F(K,L,I,J))
        END IF         
      END DO
    END DO 
    DO I = 1, NX
        THB(I,1)=1
        THB(I,NY)=1
    END DO
    DO J = 1, NY
        THA(1,J)=1
        THA(NX,J)=1    
    END DO
! VAN LEER LIMITER
    DO I = 1,NX
      DO J = 1,NY
        IF (THA(I,J) .LE. 0) THEN
            PHIA(I,J)=0
        ELSE
            PHIA(I,J)= (ABS(THA(I,J))+THA(I,J))/(1+ABS(THA(I,J)))
        END IF
        IF (THB(I,J) .LE. 0) THEN
            PHIB(I,J)=0
        ELSE
            PHIB(I,J)= (ABS(THB(I,J))+THB(I,J))/(1+ABS(THB(I,J)))
        END IF    
      END DO
    END DO
    DO I = 2, NX-1
      DO J = 2, NY-1 
        FLL(I,J) = VXP*F(K,L,I-1,J)+VXM*F(K,L,I,J)
        FLH(I,J) = 0.5D0*V(K)*(F(K,L,I-1,J)+F(K,L,I,J))-0.5D0*DTDX*V(K)**2*(F(K,L,I,J)-F(K,L,I-1,J)) 
        FL(I,J)  = FLL(I,J)+ (PHIA(I-1,J)*(FLH(I,J)-FLL(I,J)))  !F(I-1/2,J)       
        FHL(I,J) = VXP*F(K,L,I,J)+VXM*F(K,L,I+1,J)
        FHH(I,J) = 0.5D0*V(K)*(F(K,L,I,J)+F(K,L,I+1,J))-0.5D0*DTDX*V(K)**2*(F(K,L,I+1,J)-F(K,L,I,J)) 
        FH(I,J)  = FHL(I,J)+ (PHIA(I,J)*(FHH(I,J)-FHL(I,J)))   !F(I+1/2,J) 
        GLL(I,J) = VYP*F(K,L,I,J-1)+VYM*F(K,L,I,J)
        GLH(I,J) = 0.5D0*V(L)*(F(K,L,I,J-1)+F(K,L,I,J))-0.5D0*DTDY*V(L)**2*(F(K,L,I,J)-F(K,L,I,J-1))
        GL(I,J)  = GLL(I,J)+ (PHIB(I,J-1)*(GLH(I,J)-GLL(I,J))) !F(I,J-1/2)   
        GHL(I,J) = VYP*F(K,L,I,J)+VYM*F(K,L,I,J+1)
        GHH(I,J) = 0.5D0*V(L)*(F(K,L,I,J)+F(K,L,I,J+1))-0.5D0*DTDY*V(L)**2*(F(K,L,I,J+1)-F(K,L,I,J))
        GH2(I,J) = GHL(I,J)+ (PHIB(I,J)*(GHH(I,J)-GHL(I,J)))  !F(I,J+1/2)
      END DO
    END DO
RETURN
END SUBROUTINE
! 
SUBROUTINE EXPLICIT (K,L,NX,NY,FL,FH,GL,GH2,DT,DTDX,DTDY,FEQ,F,R_TIME,FN)
IMPLICIT NONE		 
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NX,NY
REAL(8) DT,DTDX,DTDY,R_TIME
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY) :: FL,FH,GL,GH2,FN
REAL, DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F,FEQ
 DO I = 2, NX-1
    DO J = 2, NY-1
	  FN(I,J) = F(K,L,I,J) - DTDX*(FH(I,J)-FL(I,J)) - DTDY*(GH2(I,J)-GL(I,J)) + DT*(FEQ(K,L,I,J)-F(K,L,I,J))/R_TIME
    END DO
 END DO
RETURN
END SUBROUTINE
!
SUBROUTINE IMPLICIT_MTD (NX,NY,K,L,VXP,VYP,VXM,VYM,FL,FH,GL,GH2,DT,DTDX,DTDY,F,FN)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER	K,L,I,J,NX,NY
REAL(8) DT,DTDX,DTDY,VXP,VYP,VXM,VYM
REAL, DIMENSION (IMAXGRIDX,IMAXGRIDY) :: FN,RHS,INVA,INVB,DQ1,DQ,FH,FL,GL,GH2
REAL, DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F
CALL RIGHT_HAND_SIDE (NX,NY,FH,FL,GH2,GL,DTDX,DTDY,RHS)
CALL INV_A (NX,NY,VXP,VYP,DT,INVA)
CALL INV_B (NX,NY,VXM,VYM,DT,INVB)
CALL MULTIPLY (NX,INVA,RHS,DQ1)
CALL MULTIPLY (NX,INVB,DQ1,DQ)
DO I = 2, NX-1
  DO J = 2, NY-1
	FN(I,J) = F(K,L,I,J) + DQ(I,J)
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE RIGHT_HAND_SIDE (NX,NY,FH,FL,GH2,GL,DTDX,DTDY,RHS)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,NX,NY
REAL(8) DTDX,DTDY
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: RHS,FH,FL,GL,GH2
DO I = 2, NX-1
  DO J = 2, NY-1
	RHS(I,J) =  - DTDX*(FH(I,J)-FL(I,J)) - DTDY*(GH2(I,J)-GL(I,J))
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE INV_A (NX,NY,VXP,VYP,DT,U)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,K,NX,NY
REAL(8) VXP,VYP,DT,BET
REAL,DIMENSION (IMAXGRIDX) :: A, B, C, GAM
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: U, R 
DO I = 3,NX-1
	A(I) = DT*(-VXP-VYP)
END DO
C(2)=A(3)
DO I = 2,NX-1
	B(I) = 1+(DT*(VXP+VYP))
END DO
DO	I = 3,NX-2
	C(I) = 0
END DO
DO I = 2,NX-1
	DO J = 2,NY-1
		R(I,J) = 0
	END DO
	R(I,I) = 1
END DO
DO  K = 2,NY-1
	BET=B(2)
	U(1,K) = R(1,K)/BET
	DO  J = 2,NX-1
		GAM(J) = C(J-1)/BET
		BET=B(J)-A(J)*GAM(J)
		U(J,K) = (R(J,K)-A(J)*U(J-1,K))/BET
	END DO 
	DO  J = NX-2,1,-1
		U(J,K) = U(J,K) - GAM(J+1)*U(J+1,K)
	END DO 
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE INV_B (NX,NY,VXM,VYM,DT,U)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,K,NX,NY
REAL(8) VXM,VYM,DT,BET
REAL,DIMENSION (IMAXGRIDX) :: A, B, C, GAM
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: U, R 
DO I = 3,NX-1
	A(I) = 0.
END DO
DO I = 2,NX-1
	B(I) = 1+DT*(-VXM-VYM)
END DO
DO	I = 2,NX-2
	C(I) = DT*(VXM+VYM)
END DO
A(NX-1)=C(NX-2)
DO I = 2,NX-1
	DO J = 2,NY-1
		R(I,J) = 0
	END DO
	R(I,I) = 1
END DO
DO  K = 2,NY-1
	BET=B(2)
	U(1,K) = R(1,K)/BET
	DO  J = 2,NX-1
		GAM(J) = C(J-1)/BET
		BET=B(J)-A(J)*GAM(J)
		U(J,K) = (R(J,K)-A(J)*U(J-1,K))/BET
	END DO 
	DO  J = NX-2,1,-1
		U(J,K) = U(J,K) - GAM(J+1)*U(J+1,K)
	END DO 
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE MULTIPLY (NX,A,B,C)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,K,NX
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) ::	A,B,C
DO I = 2,NX-1
  DO J = 2,NX-1
	  C(I,J) = 0.
  END DO
END DO
DO I = 2,NX-1
  DO J = 2,NX-1
    DO K = 2,NX-1
	  C(I,J)=C(I,J) + A(I,K)*B(K,J)
    END DO
  END DO
END DO
RETURN
END SUBROUTINE
!
SUBROUTINE B_COND(K,L,I,J,NX,NY,FN,F)
IMPLICIT NONE		  !	THIS IS A SUB-SUBROUTINE WITHIN TVDFLUXES
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER K,L,I,J,NX,NY
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: FN
REAL,DIMENSION (IGH,IGH,IMAXGRIDX,IMAXGRIDY) :: F
	F(K,L,I,1) = FN(I,3)
    F(K,L,I,NY)= FN(I,NY-2)
    F(K,L,1,J) =FN(3,J)
    F(K,L,NX,J)=FN(NX-2,J)
RETURN
END SUBROUTINE
!
SUBROUTINE WRT_RESULTS (NX,NY,X,Y,R,P,Z)
IMPLICIT NONE
INTEGER IGH,IMAXGRIDX,IMAXGRIDY
PARAMETER (IGH=20,IMAXGRIDX=400,IMAXGRIDY=400)
INTEGER I,J,NX,NY
REAL,DIMENSION (IMAXGRIDX) :: X,Y
REAL,DIMENSION (IMAXGRIDX,IMAXGRIDY) :: R,P,Z
DO I = 2, NX-1
DO J = 2, NY-1
   WRITE (60,*) X(I), Y(J), R(I,J), P(I,J), Z(I,J)
END DO 
END DO
RETURN
END SUBROUTINE